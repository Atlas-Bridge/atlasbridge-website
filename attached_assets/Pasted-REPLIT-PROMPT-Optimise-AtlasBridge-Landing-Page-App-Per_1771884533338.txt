REPLIT PROMPT — Optimise AtlasBridge Landing Page/App (Performance + Security + Compliance-Friendly)

You are improving an existing AtlasBridge landing page / web app. Your goal is to make it fast, secure, stable, accessible, and enterprise-credible.

Do not change the brand identity (logo + brand colors + typography already provided in the repo). Use existing assets and tokens.

This project is public-facing marketing + documentation entry (not a SaaS execution plane). The site must not imply remote execution control.

⸻

0) Hard Requirements

✅ Performance / Latency
	•	Reduce TTFB and LCP as much as practical.
	•	Reduce total JS shipped to the browser.
	•	Reduce blocking resources.
	•	Optimise images and fonts.
	•	Improve caching and compression.
	•	Avoid unnecessary client-side rendering for mostly static content.

✅ Security
	•	Add safe headers (CSP, HSTS where appropriate, etc.).
	•	Avoid introducing insecure dependencies.
	•	Validate/escape any user-controlled content.
	•	Prevent XSS, clickjacking, MIME sniffing, open redirects, and CSRF for any forms.
	•	Keep authentication surface minimal and secure (login button can exist but must not be misleading if auth isn’t implemented).

✅ Compliance-Friendly (Careful Wording)
	•	You may say “designed to support governance and auditability” and “security best practices” but do not claim ISO 27001 / SOC2 certification.
	•	Add privacy and security statements in a neutral, accurate way.
	•	Don’t add tracking that collects personal data by default.

✅ UX & Accessibility
	•	Meet WCAG-friendly patterns:
	•	Proper contrast
	•	Keyboard navigation
	•	Focus outlines
	•	Alt text
	•	Accessible navigation and forms

✅ DV / Business Safe Content
	•	Neutral tone.
	•	No politics.
	•	No emotional or personal language.
	•	No over-claims.

⸻

1) First: Identify Stack and Current Bottlenecks
	1.	Detect what the app is built with (e.g., Next.js, Remix, Astro, React SPA, FastAPI templates, etc.).
	2.	Identify performance bottlenecks:
	•	Large JS bundles
	•	Unoptimised images (logo pack, hero images)
	•	Render-blocking CSS
	•	Unused dependencies
	•	Lack of caching/compression
	3.	Produce a short “before” snapshot in a README section:
	•	Approx LCP/CLS/TTI (local approximation ok)
	•	Bundle sizes
	•	Main contributors to load time

Then implement improvements and provide an “after” snapshot.

⸻

2) Performance Optimisation Plan (Implement All Applicable)

A) Rendering Strategy
	•	If the site is primarily static content, prefer:
	•	SSR or static generation
	•	Minimal JS hydration
	•	Avoid SPA-only routing unless needed
	•	If using React:
	•	Code split aggressively
	•	Lazy load non-critical sections
	•	Avoid heavy animation libraries unless already included
	•	Prefer CSS animations over JS

B) Asset Optimisation
	•	Convert heavy images to modern formats (WebP/AVIF) where supported.
	•	Ensure logos are served as:
	•	SVG for vector where possible
	•	PNG fallbacks
	•	Create responsive sizes (srcset) for hero images.
	•	Ensure favicon pack is correct and referenced.
	•	Avoid shipping huge background images.

C) Fonts
	•	Use system fonts unless the brand requires Inter:
	•	If Inter is used, self-host and subset it (latin only unless needed).
	•	Preload only the necessary weights.
	•	Use font-display: swap.
	•	Avoid loading more than 2 font families.

D) CSS / JS Reduction
	•	Remove unused CSS.
	•	Remove unused dependencies.
	•	Avoid shipping big UI kits if not needed.
	•	Ensure tree-shaking works.
	•	Ensure no debug tooling ships to prod.

E) Caching & Compression
	•	Enable gzip/brotli where possible.
	•	Add immutable cache headers for static assets:
	•	Cache-Control: public, max-age=31536000, immutable for hashed assets
	•	Add reasonable caching for HTML where applicable.
	•	If using a Node server, ensure ETags are enabled.

F) Critical Path
	•	Inline critical CSS only if appropriate.
	•	Defer non-critical scripts.
	•	Use preconnect / dns-prefetch only when justified.

G) Observability (Minimal)
	•	Add lightweight performance logging locally (optional) but:
	•	Avoid third-party trackers by default.
	•	If analytics are needed, add a toggle and keep it privacy-friendly.

⸻

3) Security Hardening (Implement)

A) HTTP Security Headers

Add server-side headers (depending on framework):
	•	Content-Security-Policy (strict but practical; no unsafe-inline if possible)
	•	X-Content-Type-Options: nosniff
	•	X-Frame-Options: DENY (or CSP frame-ancestors)
	•	Referrer-Policy: no-referrer or strict-origin-when-cross-origin
	•	Permissions-Policy (disable unnecessary APIs)
	•	Strict-Transport-Security (only if served over HTTPS in prod; safe default if applicable)

B) Input Handling
	•	If any forms exist (newsletter/contact/login):
	•	server-side validation
	•	output escaping
	•	CSRF protection (if state-changing endpoints exist)
	•	If no backend exists for forms, make the UI explicit:
	•	“Login” button routes to a placeholder page that clearly states “Authentication not enabled in this build.”

C) Dependency Safety
	•	Run audit tooling available in the repo (npm audit / pip-audit).
	•	Pin versions where appropriate.
	•	Remove risky / unnecessary deps.

D) Secure Defaults
	•	No secrets in repo.
	•	Environment variables loaded via .env.example only.
	•	Ensure local dev server binds safely (localhost by default) unless explicitly configured.

⸻

4) Compliance-Friendly Pages (Add)

Add the following pages/routes with neutral wording:
	1.	/security
	•	Security principles (local-first execution, deterministic governance posture)
	•	Disclosure policy (email placeholder ok)
	•	Responsible vulnerability reporting guidance (no promises)
	2.	/privacy
	•	What data is collected (ideally none by default)
	•	Cookies policy (if any)
	•	Contact method
	3.	/terms
	•	Basic site terms and disclaimers
	•	No execution guarantees
	•	Clarify open-source license references if applicable

Important: Do not claim certifications. Use language like:
	•	“Designed to support auditability and governance workflows”
	•	“Alignment with common security best practices depends on deployment and operational controls”

⸻

5) UX Improvements (Enterprise-Grade)

Navigation
	•	Top bar:
	•	Logo left
	•	“Docs”, “GitHub”, “Security”, “Login” (Login top-left or top-right per existing design)
	•	Sticky nav on scroll
	•	Mobile responsive menu

Homepage Content

Ensure content is crisp and credible:
	•	Headline: “Controlled autonomy for AI agents.”
	•	Subtext: deterministic policy-driven runtime, local execution, structured escalation, audit integrity.
	•	CTA buttons:
	•	View Documentation
	•	GitHub Repo / Get Started
	•	Include “How it works” section with a simple diagram (SVG or HTML/CSS).

Performance-Friendly Animations
	•	Very subtle only.
	•	Avoid heavy particle effects.

Accessibility
	•	Keyboard navigation
	•	Proper focus
	•	Alt text for logos
	•	Semantic headings order
	•	Skip-to-content link

⸻

6) Build & Deployment Optimisation
	•	Ensure production build output is optimised:
	•	Minified
	•	Tree-shaken
	•	Chunked
	•	Create a PERFORMANCE.md documenting:
	•	What was changed
	•	Why it improves performance
	•	How to measure locally
	•	Create a SECURITY.md documenting:
	•	Headers
	•	Threat model summary (simple, web-only)
	•	Safe defaults

⸻

7) Acceptance Criteria (Must Meet)

Performance
	•	Reduce total JS bundle size vs baseline (report before/after).
	•	LCP improvement (best effort).
	•	Images optimised with correct formats.
	•	Fonts optimised (subset + preload or system font).

Security
	•	All key security headers present.
	•	CSP enabled and not overly permissive.
	•	No inline script injection risks introduced.
	•	No secrets in repo.
	•	Forms safe or explicitly non-functional with clear messaging.

Compliance-Friendly
	•	Add security/privacy/terms pages.
	•	No certification claims.
	•	Neutral professional tone.

Quality
	•	No broken links.
	•	No console errors.
	•	Mobile responsive.
	•	Lighthouse-style improvements where possible.

⸻

8) Deliverables
	1.	Implement the improvements.
	2.	Provide a summary:
	•	Files changed
	•	What was optimised
	•	Before/after measurements (approx ok)
	3.	Add:
	•	docs/performance.md (or PERFORMANCE.md)
	•	SECURITY.md
	•	/privacy, /terms, /security pages
	4.	Ensure the app still runs locally without extra steps.

Proceed now.
